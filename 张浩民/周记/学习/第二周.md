# 第二周学习

## Kotlin
###  类与对象
#### 继承
对应Java中的Object，Kotlin中的为Any
默认情况下，class是final的，不可继承。如果想要其可被继承，就使用**open**关键字
类似主构造和次构造的关系，**优先执行继承类的构造函数**
```kotlin
//定义一个可被继承的类Parent
open class Parent(name: String) {

	val num: Int = 24

    init {
        println("what can i say")
    }

    constructor(name:String,man:String):this(name){
        println(man)
    }
}

//Temp继承Parent，并且调用的是Parent的次构造方法
class Temp(name: String): Parent(name, "man") {
    init {
        println("$name $num")
    }
}

fun main() {
    val temp = Temp("Kobe")
}
/*
输出结果为
what can i say
man
Kobe 24
*/
```

#### 覆盖（重写）
老熟人**override**用法一样，值得关注的是，如果重写的函数前面又加上**final**关键字，那么这个函数就不能再其他类被继承了。

甚至可以覆盖变量的属性，甚至可以var覆盖val（反之不允许）

消除覆盖歧义
```kotlin
open class A {
	open fun draw(){/*...*/}
}

interface B {
	fun draw(){/*...*/}
}

class Temp: A(), B {
	//编译器要求覆盖
	override fun draw(){
		super<A>.draw()//调用A的
		super<B>.draw()//调用B的
		/*...*/
	}
}
```

#### 属性
class中的成员变量，var可以写getter和setter，val不能写getter。
而且getter或setter通常是默认的，即声明的时候就自动写了
```kotlin
var num: Int = 24
	get() {
		/*...*/
		return field//field关键字代指此变量
	}
	set(value) {
		field = value
	}
```

#### 函数式接口
```kotlin
fun main() {
    val isEven = IntPredicate { it % 2 == 0 }//lambda表达式
    println(isEven.accept(8))//true
}

fun interface IntPredicate {
    fun accept(i: Int): Boolean
}
```

#### 方法扩展
太好用了，可以对数据类型扩展自定义方法
```kotlin
fun main() {
    val num = 24
    println(num.BeATrueMan())
}

fun Int.BeATrueMan(): String {
    when{
        this == 24 -> return "Man!"
        else -> return "Out!"
    }
}
```

#### 数据类解构
```kotlin
val jane = User("Jane", 35)
val (name, age) = jane//仅限数据类
println("$name, $age years of age") 
// Jane, 35 years of age
```

#### 嵌套类
接口和类能够嵌套，内部类如果想要访问外部类的方法，需要**inner**关键字
```kotlin
class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo() // == 1
```

#### 枚举类
格式如下
```kotlin
enum class Temp {
    NORTH, SOUTH, WEST, EAST
}
```
当然，也可以进行初始化
```kotlin
enum class Temp(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
```
**匿名类**可以重写内部抽象方法，也可以实现接口
```kotlin
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    };//常量和方法用分号隔开

    abstract fun signal(): ProtocolState
}
```
每个枚举常量也都具有这两个属性：name 与 ordinal， 用于在枚举类声明中获取其名称与（自 0 起的）位置
```kotlin
enum class RGB { RED, GREEN, BLUE }

fun main() {
    //sampleStart
    println(RGB.RED.name)    // prints RED
    println(RGB.RED.ordinal) // prints 0
    //sampleEnd
}
```

#### 类型别名
typealias的应用
```kotlin
//泛型太长？缩短他们
typealias NodeSet = Set<Network.Node>
typealias FileTable<K> = MutableMap<K, MutableList<File>>

//甚至式内部类
class A {
    inner class Inner
}
typealias AInner = A.Inner
```

### 函数
#### 函数
参数可以添加默认值，在调用的时候可以**忽略默认值**，也可以使用**具名实参**来改变默认值
```kotlin
fun main() {
    println(isMan("Kobe"))
    println(isMan("Kobe", say = "Man"))
}

fun isMan(name:String, num:Int = 24, say: String = "What can I say"): String {
    val str:String?
    str = "$name is $num, said \"$say\""
    return str
}
```
## MVVM
View - ViewModel - Model

### 准备工作
在**build.gradle.kts**中开启
```java
android {
	/*...*/
	buildFeatrue {
		dataBinding = true
	}
}
```

### ViewModel使用

#### 为你的Activity/Fragment创建ViewBinding类
例如：有一个MainActivity，因为一个Activity/Fragment对应一个ViewModel，所有新建一个Class，继承ViewModel
```java
public class MainViewModel extends ViewModel {
}
```

#### 将ViewModel绑定到对应的Activity/Fragment
```java
public class MainActivity extends AppCompatActivity {

    private MainViewModel mainViewModel;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
		/*...*/
		
		//第一个参数为“容器”
		//第二个参数为所对应的ViewModel的类
        mainViewModel = new ViewModelProvider(this).get(MainViewModel.class);
    }
}
```

### LiveData使用
汉译为“鲜活数据”，这是一个用于**感知数据变化**的功能

#### 创建MutableLiveData
在所创建的MainViewModel中，添加如下变量
```java
public MutableLiveData<String> liveText = new MutableLiveData<>();
```

#### 观察与更新
在activity_main.xml中，添加EditText、TextView和Button控件
回到MainActivity，修改为如下代码
```java
public class MainActivity extends AppCompatActivity {

    private MainViewModel mainViewModel;

	//三个控件
    private EditText someText;
    private Button changeBtn;
    private TextView liveText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
		/*...*/
        
        mainViewModel = new ViewModelProvider(this).get(MainViewModel.class);

		//控件初始化
        initView();
        
        //为按钮设置监听
        initListener();
    }

    private void initListener() {
        changeBtn.setOnClickListener(v -> {
            //为liveText设置值
            mainViewModel.liveText.setValue(someText.getText().toString().trim());
            //设置观察
            //第一个参数为容器
            //第二参数为执行实例，这里用lambda表达式
            mainViewModel.liveText.observe(this, text -> liveText.setText(text));
        });
    }

    private void initView() {/*...*/}
}
```

### DataBinding使用
#### 单向绑定
现在，新建一个类User，令它继承BaseObservable
```java
public class User extends BaseObservable {
    private String name;

    public User(String name) {
        this.name = name;
    }

    @Bindable
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        notifyChange();//更新所有受绑定的控件
    }
}
```

去activity_main.xml，单击最外层的Layout，Alt+Enter根据提示创建Layout。
此时这个Layout变成了最外层的Layout，原Layout被包含了进去。
在最外层的Layout里面，添加
```xml
<data>
    <variable
        name="user"
        type="com.example.mvvm.User" />
</data>
```
并在原Layout里面添加一个TextView
```xml
<TextView
    android:id="@+id/bind_text"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@{user.name}"/>
    <!--@{}占位符的使用-->
```
现在回到MainActivity，添加代码
```java
public class MainActivity extends AppCompatActivity {

    private MainViewModel mainViewModel;
    private User user = new User("Poria");//获取实例

    private EditText someText;
    private Button changeBtn;
    private TextView liveText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
		/*...*/
        
        mainViewModel = new ViewModelProvider(this).get(MainViewModel.class);
        
        //因为activity_main.xml是绑定的
        //所以会自动生成一个ActivityMainBinding类
        ActivityMainBinding activityMainBinding = DataBindingUtil
            .setContentView(this, R.layout.activity_main);
        //设置绑定的数据类
        activityMainBinding.setUser(user);

        initView();
        initListener();
    }

    private void initListener() {
        changeBtn.setOnClickListener(v -> {
            mainViewModel.liveText.setValue(someText.getText().toString().trim());
            //对lambda表达式添加了一些代码，以触发notifyChange()
            mainViewModel.liveText.observe(this, text -> {
                liveText.setText(text);
                user.setName(text);
            });
        });
    }

    private void initView() {/*...*/}
}
```

#### 双向绑定
为了方便展示和学习，现在重写activity_main/xml、MainViewModel和MainActivity

首先是activity_main.xml，改变variable；修改里面的Layout，仅仅保留EditText和TextView
```xml
<layout ... >
	<data>
		<variable
			name="mainViewModel"
			type="mainViewModel所在的位置" />
	</data>
	
	<yourLayout>
		...
		<!--这两个控件的text，注意差别-->
		<EditText
			android:id="@+id/bind_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@={mainViewModel.user.name}"/>
            
		<TextView
            android:id="@+id/bind_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{mainViewModel.user.name}" />
	</yourLayout>
</Layout>
```

接下来是修改MainViewModel，其实就是把MutableLiveData的泛型改为了数据类User
```java
public class MainViewModel extends ViewModel {

    public MutableLiveData<User> user;

    public MutableLiveData<User> getUser() {
        if (user == null) user = new MutableLiveData<>();
        return user;
    }
}
```

最后，在MainActivity实现双向绑定吧！
```java
public class MainActivity extends AppCompatActivity {

	//老规矩，获取数据类User的实例
    private final User user = new User("Poria");

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        /*...*/

        //获取ViewModel实例
        MainViewModel mainViewModel = 
            new ViewModelProvider(this).get(MainViewModel.class);
        
        //获取对应的Binding实例
        ActivityMainBinding activityMainBinding = 
            DataBindingUtil.setContentView(this, R.layout.activity_main);

        //获取MutableLiveData实例，并为其设置数据实例
        MutableLiveData<User> mutableUser = mainViewModel.getUser();
        mutableUser.setValue(user);

        //最后，LiveData观察ViewModel
        mutableUser.observe(this, v -> activityMainBinding.setMainViewModel(mainViewModel));
    }
}
```

## Room

## LifeCycle